<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>XyAi V2</title>
  <!-- Linking Google Fonts For Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header class="header">
    <!-- Header Greetings -->
    <h1 class="title">Hello, there</h1>
    <p class="subtitle">How can I help you today?</p>

    <!-- Suggestion list -->
    <ul class="suggestion-list">
      <!-- List items -->
    </ul>
  </header>

  <!-- Chat List / Container -->
  <div class="chat-list"></div>

  <!-- Typing Area -->
  <div class="typing-area">
    <form action="#" class="typing-form">
      <div class="input-wrapper">
        <input type="text" placeholder="Enter a prompt here" class="typing-input" required />
        <button id="send-message-button" class="icon material-symbols-rounded" type="submit">send</button>
      </div>
      <div class="action-buttons">
        <span id="theme-toggle-button" class="icon material-symbols-rounded">light_mode</span>
        <span id="delete-chat-button" class="icon material-symbols-rounded">delete</span>
      </div>
    </form>
    <p class="disclaimer-text">
      XyAi may display inaccurate info, including about people, so double-check its responses. Thank you Coding Nepal for the web design, and thank you Okechukwu for the idea.
    </p>
  </div>

  <script>
const typingForm = document.querySelector(".typing-form");
const chatContainer = document.querySelector(".chat-list");
const toggleThemeButton = document.querySelector("#theme-toggle-button");
const deleteChatButton = document.querySelector("#delete-chat-button");

// State variables
let userMessage = null;
let isResponseGenerating = false;

// Simulated API URL
const apiEndpoint = 'https://akhiroai.onrender.com/api?model=chatgpt&q=';

// Load theme and chat data from local storage on page load
const loadDataFromLocalstorage = () => {
  const savedChats = localStorage.getItem("saved-chats");
  const isLightMode = (localStorage.getItem("themeColor") === "light_mode");

  // Apply the stored theme
  document.body.classList.toggle("light_mode", isLightMode);
  toggleThemeButton.innerText = isLightMode ? "dark_mode" : "light_mode";

  // Restore saved chats or clear the chat container
  chatContainer.innerHTML = savedChats || '';
  document.body.classList.toggle("hide-header", savedChats);

  chatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom
}

// Create a new message element and return it
const createMessageElement = (content, ...classes) => {
  const div = document.createElement("div");
  div.classList.add("message", ...classes);
  div.innerHTML = content;
  return div;
}

// Add message to chat history
const addToChatHistory = (message, sender) => {
  const html = `<div class="message-content">
                  <p class="text">${message}</p>
                </div>`;
  const chatMessageDiv = createMessageElement(html, sender === 'XyAi' ? "incoming" : "outgoing");
  chatContainer.appendChild(chatMessageDiv);
  chatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom
}

// Show typing effect by displaying words one by one
const showTypingEffect = (text, textElement, incomingMessageDiv) => {
  const words = text.split(' ');
  let currentWordIndex = 0;

  const typingInterval = setInterval(() => {
    // Append each word to the text element with a space
    textElement.innerText += (currentWordIndex === 0 ? '' : ' ') + words[currentWordIndex++];
    incomingMessageDiv.querySelector(".icon").classList.add("hide");

    // If all words are displayed
    if (currentWordIndex === words.length) {
      clearInterval(typingInterval);
      isResponseGenerating = false;
      incomingMessageDiv.querySelector(".icon").classList.remove("hide");
      localStorage.setItem("saved-chats", chatContainer.innerHTML); // Save chats to local storage
    }
    chatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom
  }, 75);
}

// Fetch response from the API based on user message
const generateAPIResponse = async (incomingMessageDiv) => {
  const textElement = incomingMessageDiv.querySelector(".text"); // Getting text element

  try {
    // Handle specific cases before sending the request
    if (!userMessage) {
      throw new Error("Error: Message parameter is missing.");
    }

    if (userMessage.toLowerCase() === "who created you") {
      const creatorResponse = {
        message: "Oh, you're asking about my creator? ðŸ¤– XyryllPanget is the brilliant mind behind me! He's a 15-year-old student from Aliaga, Nueva Ecija, Philippines. Quite impressive, right? ðŸ‘",
        status: "success"
      };
      addToChatHistory(creatorResponse.message, "XyAi");
      textElement.innerText = creatorResponse.message;
      return;
    }

    if (userMessage.toLowerCase().includes("xyai")) {
      if (userMessage.toLowerCase().includes("release date")) {
        const releaseDateResponse = {
          message: "XyAi was released on August 19, 2023. Feel free to ask anything else you're curious about!",
          status: "success"
        };
        addToChatHistory(releaseDateResponse.message, "XyAi");
        textElement.innerText = releaseDateResponse.message;
        return;
      } else {
        const xyaiResponse = {
          message: "XyAi is here to assist you! Feel free to ask any questions you have. How can I help you today?",
          status: "success"
        };
        addToChatHistory(xyaiResponse.message, "XyAi");
        textElement.innerText = xyaiResponse.message;
        return;
      }
    }

    if (userMessage.toLowerCase().includes("what time is it")) {
      const currentTime = new Date().toLocaleString('en-US', { timeZone: 'Asia/Manila', dateStyle: 'full', timeStyle: 'short' });
      const timeResponse = {
        message: `The current time in the Philippines is ${currentTime}.`,
        status: "success"
      };
      addToChatHistory(timeResponse.message, "XyAi");
      textElement.innerText = timeResponse.message;
      return;
    }

    // Fetch from external API
    const response = await fetch(apiEndpoint + encodeURIComponent(userMessage), {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    });

    if (!response.ok) {
      throw new Error('Network response was not ok');
    }

    const data = await response.json();

    // Check if the API response contains the expected data
    if (data.message) {
      const apiResponse = data.message.replace(/\*\*(.*?)\*\*/g, '$1');
      showTypingEffect(apiResponse, textElement, incomingMessageDiv); // Show typing effect
      addToChatHistory(apiResponse, "XyAi");
    } else {
      textElement.innerText = "Error: Unexpected response format from the API.";
      incomingMessageDiv.classList.add("error");
    }
  } catch (error) { // Handle error
    isResponseGenerating = false;
    textElement.innerText = error.message;
    textElement.parentElement.closest(".message").classList.add("error");
  } finally {
    incomingMessageDiv.classList.remove("loading");
  }
}

// Show a loading animation while waiting for the API response
const showLoadingAnimation = () => {
  const html = `<div class="message-content">
                  <p class="text">Typing<span class="dot">.</span><span class="dot">.</span><span class="dot">.</span></p>
                  <span class="icon material-symbols-rounded hide">insert_emoticon</span>
                </div>`;
  const incomingMessageDiv = createMessageElement(html, "incoming", "loading");
  chatContainer.appendChild(incomingMessageDiv);
  chatContainer.scrollTo(0, chatContainer.scrollHeight); // Scroll to the bottom
  return incomingMessageDiv;
}

// Handle form submission
typingForm.addEventListener("submit", async (e) => {
  e.preventDefault();

  if (isResponseGenerating) return;

  userMessage = typingForm.querySelector(".typing-input").value;
  typingForm.querySelector(".typing-input").value = '';

  addToChatHistory(userMessage, "You");
  const incomingMessageDiv = showLoadingAnimation();

  isResponseGenerating = true;
  await generateAPIResponse(incomingMessageDiv);
});

// Handle theme toggle button click
toggleThemeButton.addEventListener("click", () => {
  const isLightMode = document.body.classList.toggle("light_mode");
  localStorage.setItem("themeColor", isLightMode ? "light_mode" : "dark_mode");
  toggleThemeButton.innerText = isLightMode ? "dark_mode" : "light_mode";
});

// Handle delete chat button click
deleteChatButton.addEventListener("click", () => {
  if (confirm("Are you sure you want to delete the chat history?")) {
    chatContainer.innerHTML = '';
    localStorage.removeItem("saved-chats");
  }
});

// Load chat data from local storage
loadDataFromLocalstorage();
  </script>
</body>
</html>
<style>/* General body and header styles */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  display: flex;
  flex-direction: column;
  height: 100vh;
  background-color: #f4f4f4;
}

.header {
  padding: 10px;
  background-color: #333;
  color: #fff;
  text-align: center;
}

.title {
  margin: 0;
  font-size: 24px;
}

.subtitle {
  margin: 0;
  font-size: 14px;
}

/* Chat container styles */
.chat-list {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
}

.message {
  margin-bottom: 10px;
}

.message.outgoing {
  text-align: right;
}

.message.incoming {
  text-align: left;
}

.message-content {
  background-color: #fff;
  border-radius: 10px;
  padding: 10px;
  display: inline-block;
}

.message-content p.text {
  margin: 0;
}

.typing-area {
  padding: 10px;
  background-color: #ddd;
}

.typing-form {
  display: flex;
  align-items: center;
}

.typing-input {
  flex: 1;
  padding: 10px;
  border-radius: 5px;
  border: 1px solid #ccc;
}

.action-buttons {
  display: flex;
  align-items: center;
}

.icon {
  cursor: pointer;
  margin-left: 10px;
}

.hide {
  display: none;
}

.disclaimer-text {
  font-size: 12px;
  color: #666;
  margin-top: 10px;
}

/* Dark mode styles */
body.light_mode {
  background-color: #333;
  color: #fff;
}

body.light_mode .header {
  background-color: #555;
}

body.light_mode .message-content {
  background-color: #444;
}

body.light_mode .typing-area {
  background-color: #555;
}
</style>
